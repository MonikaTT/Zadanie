for (i in 1:n) {
data<-data[name.type==type_levels[i], col:=choosingcolors[i]]
}
#Wprowadzenie nazw zmiennych, które funkcja addCircleMarkers będzie          #potrafiła odczytać jako zmienne lng i lat
names(data)[which(names(data)==longtitude)]<-"lng"
names(data)[which(names(data)==latitude)]<-"lat"
#Przygotowanie mapy
map <- data %>% leaflet() %>%
addTiles() %>%
addMarkers(popup=data$name,clusterOptions=markerClusterOptions()) %>%         addCircleMarkers(color = unique(data$col)) %>%
addLegend(labels = levels(data[[name.type]]), colors=choosingcolors,
title="Legend", position="topleft")
return(map)
}
a<-Map(data = new.df, longtitude = "xo", latitude = "xa", name.type = "type")
?set
choosingcolors <- c("blue", "violet","cyan", "darkorange", "green",
"red", "yellow", "black")
new.df
x<-new.df[, col:=choosingcolors, by="type"]
x
x
new.df$col<-NULL
new.df
setkey(new.df, type)
new.df
new.df<-new.df[, col:=choosingcolors, by=type]
new.df
new.df
new.df$col<-NULL
type_type<-unique(type)
type_type<-unique(new.df$type)
type_type
length(type_type)
nn<-length(type_type)
Map <- function(data = NULL, longtitude = NULL, latitude = NULL,
name.type = NULL) {
#if(!is.factor(data[[name.type]]))
#        {stop("Argument name.type powinien być typu factor")}
#Usuwanie "pustych" kategorii w zmiennej name.type
data[[name.type]] <- as.factor(data[[name.type]])
#if(length(levels(data[[name.type]])) > 8)
#        {stop("Zmienna name.type może miec maksymanie 8 kategorii")}
#Oznaczanie kolorem poszczególnych rodzajów kategorii zmiennej
#name.tape na potrzeby wizualizacji
n <- length(levels(data[[name.type]]))
type_levels <- (levels(data[[name.type]]))
choosingcolors <- c("blue", "violet","cyan", "darkorange", "green",
"red", "yellow", "black")
for (i in 1:n) {
data<-data[get(name.type)==type_levels[i], col:=choosingcolors[i]]
}
#Wprowadzenie nazw zmiennych, które funkcja addCircleMarkers będzie          #potrafiła odczytać jako zmienne lng i lat
names(data)[which(names(data)==longtitude)]<-"lng"
names(data)[which(names(data)==latitude)]<-"lat"
#Przygotowanie mapy
map <- data %>% leaflet() %>%
addTiles() %>%
addMarkers(popup=data$name,clusterOptions=markerClusterOptions()) %>%         addCircleMarkers(color = unique(data$col)) %>%
addLegend(labels = levels(data[[name.type]]), colors=choosingcolors,
title="Legend", position="topleft")
return(map)
}
a<-Map(data = new.df, longtitude = "xo", latitude = "xa", name.type = "type")
for (i in 1:nn) {new.df<-new.df[type==type_type[i], col:=choosingcolors[i]]}
new.df
new.df
Map <- function(data = NULL, longtitude = NULL, latitude = NULL,
name.type = NULL) {
#if(!is.factor(data[[name.type]]))
#        {stop("Argument name.type powinien być typu factor")}
#Usuwanie "pustych" kategorii w zmiennej name.type
#data[[name.type]] <- as.factor(data[[name.type]])
#if(length(levels(data[[name.type]])) > 8)
#        {stop("Zmienna name.type może miec maksymanie 8 kategorii")}
#Oznaczanie kolorem poszczególnych rodzajów kategorii zmiennej
#name.tape na potrzeby wizualizacji
show_types <- unique(data[[name.type]])
#n <- length(levels(data[[name.type]]))
n <- length(show_types)
#type_levels <- (levels(data[[name.type]]))
choosingcolors <- c("blue", "violet","cyan", "darkorange", "green",
"red", "yellow", "black")
for (i in 1:n) {
data<-data[get(name.type)==show_types[i], col:=choosingcolors[i]]
}
#Wprowadzenie nazw zmiennych, które funkcja addCircleMarkers będzie          #potrafiła odczytać jako zmienne lng i lat
names(data)[which(names(data)==longtitude)]<-"lng"
names(data)[which(names(data)==latitude)]<-"lat"
#Przygotowanie mapy
map <- data %>% leaflet() %>%
addTiles() %>%
addMarkers(popup=data$name,clusterOptions=markerClusterOptions()) %>%         addCircleMarkers(color = data$col %>%
addLegend(labels = show_types), #= levels(data[[name.type]]),
colors = choosingcolors[1:n],
title="Legend", position="topleft")
return(map)
}
a<-Map(data = new.df, longtitude = "xo", latitude = "xa", name.type = "type")
Map <- function(data = NULL, longtitude = NULL, latitude = NULL,
name.type = NULL) {
#if(!is.factor(data[[name.type]]))
#        {stop("Argument name.type powinien być typu factor")}
#Usuwanie "pustych" kategorii w zmiennej name.type
#data[[name.type]] <- as.factor(data[[name.type]])
#if(length(levels(data[[name.type]])) > 8)
#        {stop("Zmienna name.type może miec maksymanie 8 kategorii")}
#Oznaczanie kolorem poszczególnych rodzajów kategorii zmiennej
#name.tape na potrzeby wizualizacji
show_types <- unique(data[[name.type]])
#n <- length(levels(data[[name.type]]))
n <- length(show_types)
#type_levels <- (levels(data[[name.type]]))
choosingcolors <- c("blue", "violet","cyan", "darkorange", "green",
"red", "yellow", "black")
for (i in 1:n) {
data<-data[get(name.type)==show_types[i], col:=choosingcolors[i]]
}
#Wprowadzenie nazw zmiennych, które funkcja addCircleMarkers będzie          #potrafiła odczytać jako zmienne lng i lat
names(data)[which(names(data)==longtitude)]<-"lng"
names(data)[which(names(data)==latitude)]<-"lat"
#Przygotowanie mapy
map <- data %>% leaflet() %>%
addTiles() %>%
addMarkers(popup=data$name,clusterOptions=markerClusterOptions()) %>%         addCircleMarkers(color = data$col) %>%
addLegend(labels = show_types, #= levels(data[[name.type]]),
colors = choosingcolors[1:n],
title="Legend", position="topleft")
return(map)
}
a<-Map(data = new.df, longtitude = "xo", latitude = "xa", name.type = "type")
a
SelectTypeDistance <- function(data = NULL, latitude = NULL,
longtitude = NULL, name.type = NULL, sel.type = NULL, sel.dist = 60){
if(!is.character(data[[name.type]]))
{stop("Argument name.type powinien być typu factor")}
data <- data.table::data.table(data)
#Wyznaczanie dystansu obiektu od centrum Krakowa
data <- data[, distance:=CalculateDistance(data = data,
longtitude = longtitude,
latitude = latitude)]
#Filtrowanie zmiennych
return(data[get(name.type) %in% sel.type & distance <= sel.dist])
}
new.df<-SelectTypeDistance(data = new.df, latitude = "lat",
longtitude = "lng", name.type = "type",
sel.type = c("Churches", "Museums"), sel.dist = 2)
new.df<-SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type",
sel.type = c("Churches", "Museums"), sel.dist = 2)
}
new.df<-SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type",
sel.type = c("Churches", "Museums"), sel.dist = 2)
df<-NULL
data(data)
new.df<-SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type",
sel.type = c("Churches", "Museums"), sel.dist = 2)
new.df
Map <- function(data = NULL, longtitude = NULL, latitude = NULL,
name.type = NULL) {
if(!is.character(data[[name.type]]))
{stop("Argument name.type powinien być typu character")}
show_types <- unique(data[[name.type]])
#n <- length(levels(data[[name.type]]))
n <- length(show_types)
if(n > 8)
{stop("Zmienna name.type może miec maksymanie 8 kategorii")}
#Oznaczanie kolorem poszczególnych rodzajów kategorii zmiennej
#name.tape na potrzeby wizualizacji
#type_levels <- (levels(data[[name.type]]))
choosingcolors <- c("blue", "violet","cyan", "darkorange", "green",
"red", "yellow", "black")
for (i in 1:n) {
data<-data[get(name.type)==show_types[i],
col:=choosingcolors[i]]
}
#Wprowadzenie nazw zmiennych, które funkcja addCircleMarkers będzie          #potrafiła odczytać jako zmienne lng i lat
names(data)[which(names(data)==longtitude)]<-"lng"
names(data)[which(names(data)==latitude)]<-"lat"
#Przygotowanie mapy
map <- data %>% leaflet() %>%
addTiles() %>%
addMarkers(popup=data$name,clusterOptions=markerClusterOptions()) %>%         addCircleMarkers(color = data$col) %>%
addLegend(labels = show_types, #= levels(data[[name.type]]),
colors = choosingcolors[1:n],
title="Legend", position="topleft")
return(map)
}
new.df <- SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type", sel.type = "Juish Culture",
sel.dist = 3)
Map(data = new.df, longtitude = "lng", latitude = "lat",
name.type = "type")
k<-Map(data = df, longtitude = "lat", latitude = "lng",
name.type = "type")
Map <- function(data = NULL, longtitude = NULL, latitude = NULL,
name.type = NULL) {
if(!is.character(data[[name.type]]))
{stop("Argument name.type powinien być typu character")}
show_types <- unique(data[[name.type]])
n <- length(show_types)
if(n > 8)
{stop("Zmienna name.type może miec maksymanie 8 kategorii")}
#Oznaczanie kolorem poszczególnych rodzajów kategorii zmiennej
#name.tape na potrzeby wizualizacji
choosingcolors <- c("blue", "violet","cyan", "darkorange", "green",
"red", "yellow", "black")
for (i in 1:n) {
data<-data[get(name.type)==show_types[i],
col:=choosingcolors[i]]
}
#Wprowadzenie nazw zmiennych, które funkcja addCircleMarkers będzie          #potrafiła odczytać jako zmienne lng i lat
names(data)[which(names(data)==longtitude)]<-"lng"
names(data)[which(names(data)==latitude)]<-"lat"
#Przygotowanie mapy
map <- data %>% leaflet() %>%
addTiles() %>%
addMarkers(popup=data$name,clusterOptions=markerClusterOptions()) %>%         addCircleMarkers(color = data$col) %>%
addLegend(labels = show_types, #= levels(data[[name.type]]),
colors = choosingcolors[1:n],
title="Legend", position="topleft")
return(map)
}
data(data)
kk<-Map(data = df, longtitude = "log", latitude = "lat",
name.type = "type")
kk
Map <- function(data = NULL, longtitude = NULL, latitude = NULL,
name.type = NULL) {
if(!is.character(data[[name.type]]))
{stop("Argument name.type powinien być typu character")}
show_types <- unique(data[[name.type]])
n <- length(show_types)
if(n > 8)
{stop("Zmienna name.type może miec maksymanie 8 kategorii")}
#Oznaczanie kolorem poszczególnych rodzajów kategorii zmiennej
#name.tape na potrzeby wizualizacji
choosingcolors <- c("blue", "violet","cyan", "darkorange", "green",
"red", "yellow", "black")
for (i in 1:n) {
data<-data[get(name.type)==show_types[i],
col:=choosingcolors[i]]
}
#Wprowadzenie nazw zmiennych, które funkcja addCircleMarkers będzie          #potrafiła odczytać jako zmienne lng i lat
names(data)[which(names(data)==longtitude)]<-"lng"
names(data)[which(names(data)==latitude)]<-"lat"
#Przygotowanie mapy
map <- data %>% leaflet() %>%
addTiles() %>%
addMarkers(popup=data$name,clusterOptions=markerClusterOptions()) %>%         addCircleMarkers(color = data$col) %>%
addLegend(labels = show_types, #= levels(data[[name.type]]),
colors = choosingcolors[1:n],
title="Legend", position="topleft")
return(map)
}
CalculateDistance <- function(data, longtitude, latitude) {
if(!is.data.frame(data))
{stop("Argument data powinien być typu data.frame")}
data <- data.table::data.table(data)
if(!is.numeric(data[[longtitude]]))
{stop("Zmienna longtitude powinna być wartością liczbową")}
if(nrow(data[get(longtitude)> 90]) > 0)
{stop("Wartość longtitude powinna mieścić się w przedziale od -90 do 90")}
if(nrow(data[get(longtitude) < -90]) > 0)
{stop("Wartość longtitude powinna mieścić się w przedziale od -90 do 90")}
if(!is.numeric(data[[latitude]]))
{stop("Zmienna latitude powinna być wartością liczbową")}
if(nrow(data[get(latitude) > 180]) > 0)
{stop("Wartość latitude powinna mieścić się w przedziale od -180 do 180")}
if(nrow(data[get(latitude) < -180]) > 0)
{stop("Wartość latitude powinna mieścić się w przedziale od -180 do 180")}
lng_lat <- as.matrix(cbind(data[[longtitude]], data[[latitude]]))
return(sp::spDistsN1(pts = lng_lat, pt = c(19.93676, 50.0619),
longlat = TRUE))
}
SelectTypeDistance <- function(data = NULL, latitude = NULL,
longtitude = NULL, name.type = NULL, sel.type = NULL, sel.dist = 60){
if(!is.character(data[[name.type]]))
{stop("Argument name.type powinien być typu character")}
data <- data.table::data.table(data)
#Wyznaczanie dystansu obiektu od centrum Krakowa
data <- data[, distance:=CalculateDistance(data = data,
longtitude = longtitude,
latitude = latitude)]
#Filtrowanie zmiennych
return(data[get(name.type) %in% sel.type & distance <= sel.dist])
}
new.df <- SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type", sel.type = "Juish Culture",
sel.dist = 3)
Map(data = new.df, longtitude = "lng", latitude = "lat",
name.type = "type")
data(data)
new.df <- SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type", sel.type = "Juish Culture",
sel.dist = 3)
Map(data = new.df, longtitude = "lng", latitude = "lat",
name.type = "type")
new.df <- SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type", sel.type = c("Juish Culture", Museums),
sel.dist = 8)
new.df <- SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type", sel.type = c("Juish Culture", "Museums"),
sel.dist = 8)
Map(data = new.df, longtitude = "lng", latitude = "lat",
name.type = "type")
new.df <- SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type", sel.type = c"Juish Culture",
sel.dist = 3)
Map(data = new.df, longtitude = "lng", latitude = "lat",
name.type = "type")
new.df <- SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type", sel.type = c"Juish Culture",
sel.dist = 3)
new.df <- SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type", sel.type = "Juish Culture",
sel.dist = 3)
Map(data = new.df, longtitude = "lng", latitude = "lat",
name.type = "type")
new.df
new.df
table(df$type)
new.df <- SelectTypeDistance(data = df, latitude = "lat",
longtitude = "lng", name.type = "type", sel.type = c("Juish Culture", "Old Buildings", "Fortifications"),
sel.dist = 3)
new.df
names(new.df)[2]<-"rrra"
names(new.df)[3]<-"rrroo"
a<-Map(data = new.df, longtitude = "rrroo", latitude = "rrra", name.type = "type")
a
test_that("testowanie typu argumentu name.type",{
xy <- data.frame(c(24.6, 13.40032, -89.4, 0, 45.6, 1:3),
c(180, -180, 8.29910100, 0, 10.9086, 1:3),
1:8)
names(xy) <- c("lng", "lat", "type")
expect_that(SelectTypeDistance(data = xy, longtitude = "lng",
latitude = "lat", name.type = "type", sel.type = "1"),
throws_error("Argument name.type powinien być typu character"))
})
document()
document()
library(Zadanie)
document()
context("testowanie zmiennych na wejściu")
test_that("testowanie formatu zmiennej data",{
x <- as.numeric(1:5)
y <- as.numeric(20:24)
xy <- c(39, 30, 90, 0, -12.999292)
expect_that(CalculateDistance(xy, "x", "y"),
throws_error("Argument data powinien być typu data.frame"))
})
test_that("testowanie formatu zmiennej lngtitude",{
xy <- data.frame(c("k", 33.4, "a"), c(-3, 6.99, 90))
names(xy) <- c("x", "y")
expect_that(CalculateDistance(xy, "x", "y"),
throws_error("Zmienna longtitude powinna być wartością liczbową"))
})
test_that("testowanie zakresu zmiennej lngtitude",{
xy <- data.frame(c(-10, 33.4, 200), c(-3, 6.99, 90))
names(xy) <- c("x", "y")
expect_that(CalculateDistance(xy, "x", "y"),
throws_error("Wartość longtitude powinna mieścić się w przedziale od -90 do 90"))
})
test_that("testowanie zakresu zmiennej lngtitude",{
xy <- data.frame(c(-20, 33.4, 95, 1.9499), c(-3, 6.99, 180, -45.99997))
names(xy) <- c("x", "y")
expect_that(CalculateDistance(xy, "x", "y"),
throws_error("Wartość longtitude powinna mieścić się w przedziale od -90 do 90"))
})
test_that("testowanie formatu zmiennej latitude",{
xy <- data.frame(c(89, 33.4, 1), c("rty", 6.99, 90))
names(xy) <- c("x", "y")
expect_that(CalculateDistance(xy, "x", "y"),
throws_error("Zmienna latitude powinna być wartością liczbową"))
})
test_that("testowanie zakresu zmiennej latitude",{
xy <- data.frame(c(-90, 33.4, 18.97838292), c(-180.99827, 6.99, 90))
names(xy) <- c("x", "y")
expect_that(CalculateDistance(xy, "x", "y"),
throws_error("Wartość latitude powinna mieścić się w przedziale od -180 do 180"))
})
test_that("testowanie zakresu zmiennej latitude",{
xy <- data.frame(c(-20, 33.4, 90), c(-3, 6.99, 1000))
names(xy) <- c("x", "y")
expect_that(CalculateDistance(xy, "x", "y"),
throws_error("Wartość latitude powinna mieścić się w przedziale od -180 do 180"))
})
context("testowanie rezultatów na wyjściu")
test_that("wynik jest wartością numeryczną",{
xy <- data.frame(c(90, 28.9292992, -18.34, 0), c(178.993, 95, 0, -114.92928290023))
names(xy) <- c("x", "y")
expect_that(CalculateDistance(xy, "x", "y"), is_a("numeric"))
})
context("testowanie zmiennych na wejściu")
test_that("testowanie typu argumentu name.type",{
xy <- data.frame(c(24.6, 13.40032, -89.4, 0, 45.6, 1:3),
c(180, -180, 8.29910100, 0, 10.9086, 1:3),
1:8)
names(xy) <- c("lng", "lat", "type")
expect_that(SelectTypeDistance(data = xy, longtitude = "lng",
latitude = "lat", name.type = "type", sel.type = "1"),
throws_error("Argument name.type powinien być typu character"))
})
context("testowanie rezultatów na wyjściu")
test_that("wynik jest obiektem data.table",{
xy<-data.frame(1:5, (10:14), c("raz", "raz", "dwa", "dwa", "dwa"))
names(xy) <- c("lng", "lat", "type")
expect_that(SelectTypeDistance(data = xy, longtitude = "lng",
latitude = "lat", name.type = "type", sel.type = "raz"),
is_a("data.table"))
})
xy<-data.frame(1:5, (10:14), c("raz", "raz", "dwa", "dwa", "dwa"))
names(xy) <- c("lng", "lat", "type")
str(xy)
context("testowanie zmiennych na wejściu")
test_that("testowanie typu argumentu name.type",{
xy <- data.frame(c(24.6, 13.40032, -89.4, 0, 45.6, 1:3),
c(180, -180, 8.29910100, 0, 10.9086, 1:3),
1:8)
names(xy) <- c("lng", "lat", "type")
expect_that(SelectTypeDistance(data = xy, longtitude = "lng",
latitude = "lat", name.type = "type", sel.type = "1"),
throws_error("Argument name.type powinien być typu character"))
})
context("testowanie rezultatów na wyjściu")
test_that("wynik jest obiektem data.table",{
xy<-data.frame(1:5, (10:14), c("raz", "raz", "dwa", "dwa", "dwa"))
names(xy) <- c("lng", "lat", "type")
xy$type <- as.character(xy$type)
expect_that(SelectTypeDistance(data = xy, longtitude = "lng",
latitude = "lat", name.type = "type", sel.type = "raz"),
is_a("data.table"))
})
getwd()
getwd()
library(devtools)
library(roxygen2)
document()
document()
data(df)
data(data)
document()
load("~/Documents/7N/Zadanie/data/data.RData")
library(Zadanie)
document()
CalculateDistance <- function(data, longtitude, latitude) {
if(!is.data.frame(data))
{stop("Argument data powinien być typu data.frame")}
data <- data.table::data.table(data)
if(!is.numeric(data[[longtitude]]))
{stop("Zmienna longtitude powinna być wartością liczbową")}
if(nrow(data[get(longtitude)> 90]) > 0)
{stop("Wartość longtitude powinna mieścić się w przedziale od -90 do 90")}
if(nrow(data[get(longtitude) < -90]) > 0)
{stop("Wartość longtitude powinna mieścić się w przedziale od -90 do 90")}
if(!is.numeric(data[[latitude]]))
{stop("Zmienna latitude powinna być wartością liczbową")}
if(nrow(data[get(latitude) > 180]) > 0)
{stop("Wartość latitude powinna mieścić się w przedziale od -180 do 180")}
if(nrow(data[get(latitude) < -180]) > 0)
{stop("Wartość latitude powinna mieścić się w przedziale od -180 do 180")}
lng_lat <- as.matrix(cbind(data[[longtitude]], data[[latitude]]))
return(sp::spDistsN1(pts = lng_lat, pt = c(19.93676, 50.0619),
longlat = TRUE))
}
SelectTypeDistance <- function(data = NULL, latitude = NULL,
longtitude = NULL, name.type = NULL, sel.type = NULL, sel.dist = 60){
if(!is.character(data[[name.type]]))
{stop("Argument name.type powinien być typu character")}
data <- data.table::data.table(data)
#Wyznaczanie dystansu obiektu od centrum Krakowa
data <- data[, distance:=CalculateDistance(data = data,
longtitude = longtitude,
latitude = latitude)]
#Filtrowanie zmiennych
return(data[get(name.type) %in% sel.type & distance <= sel.dist])
}
Map <- function(data = NULL, longtitude = NULL, latitude = NULL,
name.type = NULL) {
if(!is.character(data[[name.type]]))
{stop("Argument name.type powinien być typu character")}
show_types <- unique(data[[name.type]])
n <- length(show_types)
if(n > 8)
{stop("Zmienna name.type może miec maksymanie 8 kategorii")}
#Oznaczanie kolorem poszczególnych rodzajów kategorii zmiennej
#name.tape na potrzeby wizualizacji
choosingcolors <- c("blue", "violet","cyan", "darkorange", "green",
"red", "yellow", "black")
for (i in 1:n) {
data<-data[get(name.type)==show_types[i],
col:=choosingcolors[i]]
}
#Wprowadzenie nazw zmiennych, które funkcja addCircleMarkers będzie          #potrafiła odczytać jako zmienne lng i lat
names(data)[which(names(data)==longtitude)]<-"lng"
names(data)[which(names(data)==latitude)]<-"lat"
#Przygotowanie mapy
map <- data %>% leaflet() %>%
addTiles() %>%
addMarkers(popup=data$name,clusterOptions=markerClusterOptions()) %>%         addCircleMarkers(color = data$col) %>%
addLegend(labels = show_types, #= levels(data[[name.type]]),
colors = choosingcolors[1:n],
title="Legend", position="topleft")
return(map)
}
library(Zadanie)
library(devtools)
library(testthat)
library(roxygen2)
document()
